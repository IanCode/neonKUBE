//-----------------------------------------------------------------------------
// FILE:	    AesCipher.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:	Copyright (c) 2016-2019 by neonFORGE, LLC.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Security.Cryptography;
using System.Text;

using Neon.Common;

// $todo(jeff.lill):
//
// This needs a review to ensure that we're not leaving decrypted
// data laying about in RAM unnecessarily.  One thing I should really
// look into is using [SecureString] where possible.

namespace Neon.Cryptography
{
    /// <summary>
    /// Implements a convienent wrapper over <see cref="AesManaged"/> that handles
    /// the encryption and decryption of data using the AES algorthim.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class uses the <see cref="BinaryWriter"/> to generate the encrypted
    /// output and <see cref="BinaryReader"/> to read it.
    /// </para>
    /// <para>
    /// The encrypted data is formatted like:
    /// </para>
    /// <code>
    /// +------------------+
    /// |    0x3BBAA035    |    32-bit magic number (for verification)
    /// +------------------+
    /// |     IV Size      |    16-bits
    /// +------------------+
    /// |                  |
    /// |                  |
    /// |     IV Bytes     |    IV Size bytes
    /// |                  |
    /// |                  |
    /// +------------------+
    /// |                  |
    /// |                  |
    /// |    Data Bytes    |    Data bytes
    /// |                  |
    /// |                  |
    /// +------------------+
    /// </code>
    /// <note>
    /// Note that this encodes multi-byte integers using little endian byte ordering
    /// via <see cref="BinaryWriter"/> and <see cref="BinaryReader"/>.
    /// </note>
    /// <para>
    /// This class automatically generates a new initialization vector for every
    /// encyption operation.  This ensures that every encryption operation will
    /// generate different ciphertext even when the key and data haven't changed
    /// to enhance security.
    /// </para>
    /// <para>
    /// The class is designed to be easier to use than the .NET Core <see cref="AesManaged"/>
    /// base implementation.
    /// </para>
    /// <para>
    /// To encrypt data:
    /// </para>
    /// <list type="number">
    /// <item>
    /// Generate an encryption key via <see cref="GenerateKey(int)"/> and create an instance
    /// via <see cref="AesCipher(string)"/> passing the key, or just call <see cref="AesCipher(int)"/>
    /// to create an instance with an already populated random key.
    /// </item>
    /// <item>
    /// You can always obtain the key via the <see cref="Key"/> property.
    /// </item>
    /// <item>
    /// Call one of <see cref="EncryptToBase64(byte[])"/>, <see cref="EncryptToBase64(byte[])"/>, 
    /// <see cref="EncryptToBytes(string)"/>, or <see cref="EncryptToBytes(byte[])"/> to perform
    /// the encryption with varying input and output formats.
    /// </item>
    /// </list>
    /// <para>
    /// To decrypt data:
    /// </para>
    /// <list type="number">
    /// <item>
    /// Use <see cref="AesCipher(string)"/> to construct and instance using the key originally
    /// used to encrypt the data.
    /// </item>
    /// <item>
    /// Call one of <see cref="DecryptBytesFrom(byte[])"/>, <see cref="DecryptBytesFrom(string)"/>,
    /// <see cref="DecryptStringFrom(byte[])"/>, or <see cref="DecryptStringFrom(byte[])"/>.
    /// to decrypt data.
    /// </item>
    /// </list>
    /// </remarks>
    public sealed class AesCipher : IDisposable
    {
        //---------------------------------------------------------------------
        // Static members

        /// <summary>
        /// The 32-bit magic number that will be written in plaintext to the
        /// beginning of the encrypted output to be used to verify that 
        /// encrypted buffers will generated by this class.
        /// </summary>
        public const int Magic = 0x3BBAA035;

        /// <summary>
        /// Generates a random encryption key with the specified size in bits.
        /// </summary>
        /// <param name="keySize">The key size in bits (default <b>256</b>).</param>
        /// <returns>The key encoded as base-64.</returns>
        /// <remarks>
        /// Note that only these key sizes are currently supported: <b>128</b>, <b>192</b>,
        /// and <b>256</b> bits.  Only 256 bits is currently considered to be secure.
        /// </remarks>
        public static string GenerateKey(int keySize = 256)
        {
            Covenant.Requires<ArgumentException>(keySize == 128 || keySize == 192 || keySize == 256);

            using (var aes = new AesManaged())
            {
                aes.KeySize = keySize;

                aes.GenerateKey();

                return Convert.ToBase64String(aes.Key);
            }
        }

        //---------------------------------------------------------------------
        // Instance members

        private AesManaged aes;

        /// <summary>
        /// Constructs an AES cypher using a specific encryption key.
        /// </summary>
        /// <param name="key">The base-64 encoded key.</param>
        public AesCipher(string key)
        {
            Covenant.Requires<ArgumentNullException>(!string.IsNullOrEmpty(key));

            var keyBytes = Convert.FromBase64String(key);

            switch (keyBytes.Length * 8)
            {
                case 128:
                case 192:
                case 256:

                    break;

                default:

                    throw new ArgumentException($"Invalid key [size={keyBytes.Length * 8}].  Only these sizes are currently supported: 128, 192, and 256.");
            }

            aes = new AesManaged()
            {
                Key = keyBytes
            };
        }

        /// <summary>
        /// Constructs an AES cypher using a randomly generated encyption key.
        /// </summary>
        /// <param name="keySize">Optionally specifies the key size (defaults to <b>256 bits</b>).</param>
        /// <remarks>
        /// Note that only these key sizes are currently supported: <b>128</b>, <b>192</b>,
        /// and <b>256</b> bits.  Only 256 bits is currently considered to be secure.
        /// </remarks>
        public AesCipher(int keySize = 256)
        {
            Covenant.Requires<ArgumentException>(keySize == 128 || keySize == 192 || keySize == 256);

            aes = new AesManaged()
            {
                KeySize = keySize
            };

            aes.GenerateKey();
        }

        /// <inheritdoc/>
        public void Dispose()
        {
            if (aes != null)
            {
                aes.Dispose();
                aes = null;
            }
        }

        /// <summary>
        /// Ensures that the instance hasn't been disposed.
        /// </summary>
        private void EnsureNotDisposed()
        {
            if (aes == null)
            {
                throw new ObjectDisposedException(nameof(AesCipher));
            }
        }

        /// <summary>
        /// Returns the encyption key encoded as base-64.
        /// </summary>
        public string Key
        {
            get
            {
                EnsureNotDisposed();

                return Convert.ToBase64String(aes.Key);
            }
        }

        //---------------------------------------------------------------------
        // Encryption methods:

        /// <summary>
        /// Encrypts the text passed returning the result encoded as
        /// a byte array.
        /// </summary>
        /// <param name="decryptedBytes">The unencrypted bytes.</param>
        /// <returns>The encrypted result as bytes.</returns>
        public byte[] EncryptToBytes(byte[] decryptedBytes)
        {
            Covenant.Requires<ArgumentNullException>(decryptedBytes != null);

            using (var encryptor = aes.CreateEncryptor())
            {
                using (var msEncrypted = new MemoryStream())
                {
                    using (var writer = new BinaryWriter(msEncrypted, Encoding.UTF8, leaveOpen: true))
                    {
                        writer.Write((int)Magic);
                        writer.Write((short)aes.IV.Length);
                        writer.Write(aes.IV);
                        writer.Flush();
                    }

                    using (var csEncrypted = new CryptoStream(msEncrypted, encryptor, CryptoStreamMode.Write))
                    {
                        csEncrypted.Write(decryptedBytes, 0, decryptedBytes.Length);

                        if (!csEncrypted.HasFlushedFinalBlock)
                        {
                            csEncrypted.FlushFinalBlock();
                        }
                    }

                    return msEncrypted.ToArray();
                }
            }
        }

        /// <summary>
        /// Encrypts the text passed returning the result encoded as
        /// a byte array.
        /// </summary>
        /// <param name="decryptedText">The unencrypted text.</param>
        /// <returns>The encrypted result as bytes.</returns>
        public byte[] EncryptToBytes(string decryptedText)
        {
            Covenant.Requires<ArgumentNullException>(decryptedText != null);

            return EncryptToBytes(Encoding.UTF8.GetBytes(decryptedText));
        }

        /// <summary>
        /// Encrypts the text passed returning the result encoded as base-64.
        /// </summary>
        /// <param name="decryptedText">The unencrypted text.</param>
        /// <returns>The encrypted result as base-64.</returns>
        public string EncryptToBase64(string decryptedText)
        {
            Covenant.Requires<ArgumentNullException>(decryptedText != null);

            var encryptedBytes = EncryptToBytes(Encoding.UTF8.GetBytes(decryptedText));

            return Convert.ToBase64String(encryptedBytes);
        }

        /// <summary>
        /// Encrypts the bytes passed returning the result encoded as base-64.
        /// </summary>
        /// <param name="decryptedBytes">The unencrypted text.</param>
        /// <returns>The encrypted result as base-64.</returns>
        public string EncryptToBase64(byte[] decryptedBytes)
        {
            Covenant.Requires<ArgumentNullException>(decryptedBytes != null);

            var encryptedBytes = EncryptToBytes(decryptedBytes);

            return Convert.ToBase64String(encryptedBytes);
        }

        //---------------------------------------------------------------------
        // Decryption methods:

        /// <summary>
        /// Decrypts the encrypted base-64 text passed returning the result as 
        /// a byte array.
        /// </summary>
        /// <param name="encryptedBytes">The encrypted bytes.</param>
        /// <returns>The encrypted result as a string.</returns>
        public byte[] DecryptBytesFrom(byte[] encryptedBytes)
        {
            Covenant.Requires<ArgumentNullException>(encryptedBytes != null);

            using (var msDecrypted = new MemoryStream())
            {
                using (var msEncrypted = new MemoryStream(encryptedBytes))
                {
                    using (var reader = new BinaryReader(msEncrypted, Encoding.UTF8, leaveOpen: true))
                    {
                        // Read and verify the unencrypted magic number.

                        try
                        {
                            if (reader.ReadInt32() != Magic)
                            {
                                throw new FormatException($"The encrypted was not generated by [{nameof(AesCipher)}].");
                            }
                        }
                        catch (IOException e)
                        {
                            throw new FormatException($"The encrypted data has been truncated or it was not generated by [{nameof(AesCipher)}].", e);
                        }

                        // Read the unencrypted IV:

                        var ivLength = reader.ReadInt16();

                        aes.IV = reader.ReadBytes(ivLength);
                    }

                    using (var decryptor = aes.CreateDecryptor())
                    {
                        using (var csDecrypted = new CryptoStream(msEncrypted, decryptor, CryptoStreamMode.Read))
                        {
                            csDecrypted.CopyTo(msDecrypted);
                        }

                        return msDecrypted.ToArray();
                    }
                }
            }
        }

        /// <summary>
        /// Decrypts the encrypted base-64 text passed returning the result as 
        /// a byte array.
        /// </summary>
        /// <param name="encryptedBase64">The encrypted base-64 text.</param>
        /// <returns>The encrypted result as a string.</returns>
        public byte[] DecryptBytesFrom(string encryptedBase64)
        {
            Covenant.Requires<ArgumentNullException>(encryptedBase64 != null);

            var encryptedBytes = Convert.FromBase64String(encryptedBase64);

            return DecryptBytesFrom(encryptedBytes);
        }

        /// <summary>
        /// Decrypts the encrypted bytes passed returning the result as a string.
        /// </summary>
        /// <param name="encryptedBase64">The encrypted base-64 text.</param>
        /// <returns>The encrypted result as a base-64 string.</returns>
        public string DecryptStringFrom(byte[] encryptedBytes)
        {
            Covenant.Requires<ArgumentNullException>(encryptedBytes != null);

            var decryptedBytes = DecryptBytesFrom(encryptedBytes);

            return Encoding.UTF8.GetString(decryptedBytes);
        }

        /// <summary>
        /// Decrypts the encrypted base-64 text passed returning the result as a string.
        /// </summary>
        /// <param name="encryptedBase64">The encrypted base-64 text.</param>
        /// <returns>The encrypted result as a base-64 string.</returns>
        public string DecryptStringFrom(string encryptedBase64)
        {
            Covenant.Requires<ArgumentNullException>(encryptedBase64 != null);

            var encryptedBytes = Convert.FromBase64String(encryptedBase64);
            var decryptedBytes = DecryptBytesFrom(encryptedBytes);

            return Encoding.UTF8.GetString(decryptedBytes);
        }
    }
}
